# สรุปผลและคำถามท้ายการทดลอง

## สรุปผลการทดลอง


## คำถามท้ายการทดลอง

1. นักศึกษาได้เรียนรู้อะไรบ้างเกี่ยวกับความแตกต่างและคุณสมบัติของชนิดข้อมูลแต่ละประเภทบน ESP32 (เช่น int, float, char, bool, long, long long, unsigned int, byte, double)

- ขนาดของข้อมูล (Memory Size) เช่น int, long ใช้ 4 ไบต์ long long, unsigned long long ใช้ 8 ไบต์

- ช่วงค่าที่เก็บได้ (Value Range) เช่น int และ long เก็บจำนวนเต็ม signed ช่วง -2,147,483,648 ถึง 2,147,483,647

- ความแม่นยำและการใช้งาน 

- การใช้งานจริง เช่น เลือกใช้ bool เพื่อแทนสถานะจริง/เท็จ หรือใช้ char เพื่อเก็บตัวอักษรและแปลงเป็น ASCII ได้

2. ความสำคัญของการเลือกใช้ชนิดข้อมูลที่เหมาะสมในการเขียนโปรแกรมคืออะไร?

- ประสิทธิภาพในการทำงาน
  
- ลดข้อผิดพลาดและบั๊ก
  
- ความแม่นยำของข้อมูล

- ความเข้าใจและบำรุงรักษาโค้ดง่ายขึ้น

- การทำงานร่วมกับฮาร์ดแวร์และไลบรารี

3. ถ้านักศึกษาต้องการเก็บค่าเวลา (เป็นมิลลิวินาที) ซึ่งอาจมีค่าสูงถึงหลายพันล้านมิลลิวินาที นักศึกษาควรใช้ชนิดข้อมูลใดบน ESP32

- unsigned long long (64 บิต) เพราะ เก็บค่าบวกได้สูงสุดประมาณ 18,446,744,073,709,551,615 ซึ่งเพียงพอสำหรับเก็บเวลาหลายพันล้านมิลลิวินาที (เช่น 3,000,000,000 ms)

  
4. อธิบายความแตกต่างระหว่าง float และ double ในแง่ของขนาดหน่วยความจำและความแม่นยำ

- ขนาดหน่วยความจำ (Memory Size)
  
  float ใช้พื้นที่ 4 ไบต์ double บนระบบทั่วไป ใช้ 8 ไบต์ แต่บน ESP32 ใช้ 4 ไบต์เท่ากับ float

- ความแม่นยำ (Precision)
  
  float มีความแม่นยำประมาณ 6-7 หลักทศนิยม
  
  double บนระบบทั่วไป มีความแม่นยำประมาณ 15-16 หลักทศนิยมแต่บน ESP32 ความแม่นยำเหมือนกับ float เพราะใช้ขนาด 4 ไบต์
5. อธิบายแนวคิดเรื่อง "Overflow" และ "Underflow" ที่เกิดขึ้นกับชนิดข้อมูลจำนวนเต็ม (เช่น int, byte) พร้อมยกตัวอย่างจากใบงานนี้

- Overflow เกิดขึ้นเมื่อค่าที่เก็บในตัวแปรชนิดจำนวนเต็มเกินขอบเขตสูงสุดที่ชนิดข้อมูลนั้นรองรับค่าจะม้วนกลับไปเริ่มนับจากค่าต่ำสุดใหม่

    ตัวอย่าง Overflow จากใบงาน

      ชนิดข้อมูล long บน ESP32 เป็น signed 32-bit ขอบเขตค่าที่เก็บได้: -2,147,483,648 ถึง 2,147,483,647

      แต่โค้ดกำหนดค่า:

            long myLong = 4000000000L; // 4,000,000,000 เกินขอบเขต
            Serial.println(myLong);

      เนื่องจาก 4,000,000,000 เกินขอบเขตสูงสุดของ long จึงเกิด overflow

      ผลลัพธ์ที่แสดงจะเป็นค่าผิดเพี้ยน เช่น -294,967,296

- Underflow โดยทั่วไปในจำนวนเต็ม Underflow หมายถึงการเก็บค่าต่ำสุดเกินขอบเขตต่ำสุดของชนิดข้อมูลเช่น ถ้าค่าต่ำสุดของ int คือ -2,147,483,648 ถ้าเราลดค่าลงไปเกินกว่านี้ จะเกิดการม้วนกลับไปค่าบวกสูงสุด
 
- Overflow กับ byte
  
      byte เก็บค่าได้ 0 ถึง 255 ถ้ากำหนดค่าเกิน 255 เช่น 256 จะเกิดการ overflow
  
          byte myByte = 256; // เกินขอบเขต 0-255
          Serial.println(myByte); // ผลลัพธ์จะเป็น 0 เพราะ 256 mod 256 = 0

6. การทราบขนาดของชนิดข้อมูลด้วย sizeof() มีประโยชน์อย่างไรในการเขียนโปรแกรมสำหรับไมโครคอนโทรลเลอร์ที่มีหน่วยความจำจำกัด?

- จัดการหน่วยความจำอย่างมีประสิทธิภาพ
  
- ป้องกันปัญหา Overflow และ Memory Corruption

- ช่วยในการจัดโครงสร้างข้อมูล (Structs, Arrays)

- เพิ่มความเข้ากันได้ในการสื่อสารข้อมูล

- ทำให้โค้ดมีความยืดหยุ่นและพกพาง่าย
